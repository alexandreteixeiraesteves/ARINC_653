open Complex
open Twiddle
open Bitrev
fun butterfly<<n:int>>(i1:complex^(n/2); i2:complex^(n/2)) returns (o:complex^n)
var
	o1 : complex^(n/2);
	p : complex^(n/2);
	r : complex^(n/2);
let
	o1 = map<< (n/2) >> complex_add (i1, i2);
	p = map<< (n/2) >> complex_sub (i1, i2);
	r = map<< (n/2) >> complex_mul (p, c);
	o = o1@r;
tel

fun bf<<n:int>>(i:complex^n) returns (o:complex^n)
var
	i1 : complex^(n/2);
	i2 : complex^(n/2);
let
	i1 = i[0..(n/2)-1];
	i2 = i[(n/2)..n-1];
	o = butterfly<<n>>(i1, i2);
tel
const n1: int = 2
fun fft_aux2(i:complex^2) returns (o:complex^2)
var
	o1 : complex^2;
let
	o1 = bf<<n1>>(i);
	o = bf<<n1>>(o1);
tel

fun fft_aux4 (i:complex^4 ) returns (out:complex^4 )
var
	o : complex^4;
let
	o = fft_aux2(i[0..2])@fft_aux2(i[2..4]);
	out = fft_aux2(o[0..2])@fft_aux2(o[2..4]);
tel

fun fft_aux8 (i:complex^8 ) returns (out:complex^8 )
var
	o : complex^8;
let
	o = fft_aux4(i[0..4])@fft_aux4(i[4..8]);
	out = fft_aux4(o[0..4])@fft_aux4(o[4..8]);
tel

fun fft_aux16 (i:complex^16 ) returns (out:complex^16 )
var
	o : complex^16;
let
	o = fft_aux8(i);
	out = fft_aux8(o);
	o = fft_aux8(i[0..8])@fft_aux8(i[8..16]);
	out = fft_aux8(o[0..8])@fft_aux8(o[8..16]);
tel

fun fft8 (i:complex^8 ) returns (out:complex^8 )
var
	o : complex^8;
let
	o = fft_aux8(i);
	out = bitrev8(o);
tel
fun fft16 (i:complex^16 ) returns (out:complex^16 )
var
	o : complex^16;
let
	out = fft_aux16(i);
	o = out;
	out = bitrev16(o);
tel


