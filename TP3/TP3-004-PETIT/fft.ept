open Complex
open Twiddle
open Bitrev
node butterfly<<n:int>>(i1:complex^(n/2); i2:complex^(n/2)) returns (o:complex^n)
var
	o1 : complex^(n/2);
	p : complex^(n/2);
	r : complex^(n/2);
let
	o1 = map<< (n/2) >> complex_add (i1, i2);
	p = map<< (n/2) >> complex_sub (i1, i2);
	r = map<< (n/2) >> complex_mul (c, p);
	o = o1@r;
tel

node bf<<n:int>>(i:complex^n) returns (o:complex^n)
var
	i1 : complex^(n/2);
	i2 : complex^(n/2);
let
	i1 = i[0..(n/2)];
	i2 = i[(n/2)..n];
	o = butterfly<<n>>(i1, i2);
	
tel
const n1: int = 2
node fft_aux2 (i:complex^2 ) returns (out:complex^2 )
var
	o : complex^2;
	o1 : complex^2;
let
	out = bf<<n1>>(i);
	out = bf<<n1>>(out);
tel

node fft_aux4 (i:complex^4 ) returns (out:complex^4 )
var
	o : complex^4;
let
	o = fft_aux2(i);
	out = fft_aux2(o);
tel

node fft_aux8 (i:complex^8 ) returns (out:complex^8 )
var
	o : complex^8;
let
	o = fft_aux4(i);
	out = fft_aux4(o);
tel

node fft_aux16 (i:complex^16 ) returns (out:complex^16 )
var
	o : complex^16;
let
	o = fft_aux8(i);
	out = fft_aux8(o);
tel

node fft8 (i:complex^8 ) returns (out:complex^8 )
var
	o : complex^8;
let
	o = fft_aux8(i);
	out = bitrev8(o);
tel
node fft16 (i:complex^16 ) returns (out:complex^16 )
var
	o : complex^16;
let
	out = fft_aux16(i);
	o = out;
	out = bitrev16(o);
tel


